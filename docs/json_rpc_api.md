### Table of Contents
1. [Overview](#Overview)<br />
2. [HTTP POST Versus Websockets](#HttpPostVsWebsockets)<br />
3. [Authentication](#Authentication)<br />
3.1.  [Overview](#AuthenticationOverview)<br />
3.2.  [HTTP Basic Access Authentication](#HTTPAuth)<br />
3.3.  [JSON-RPC Authenticate Command (Websocket-specific)](#JSONAuth)<br />
4. [Command-line Utility](#CLIUtil)<br />
5. [Standard Methods](#Methods)<br />
5.1. [Method Overview](#MethodOverview)<br />
5.2. [Method Details](#MethodDetails)<br />
6. [Websocket Methods (Websocket Specific) ](#WSMethods)<br />
6.1. [Method Overview](#WSMethodOverview)<br />
6.2. [Method Details](#WSMethodDetails)<br />
7. [Notifications (Websocket-specific)](#Notifications)<br />
7.1. [Notification Overview](#NotificationOverview)<br />
7.2. [Notification Details](#NotificationDetails)<br />
8. [Example Code](#ExampleCode)<br />
8.1. [Go](#ExampleGoApp)<br />
8.2. [node.js](#ExampleNodeJsCode)<br />

<a name="Overview" />

### 1. Overview

hcd provides a [JSON-RPC](http://json-rpc.org/wiki/specification) API that is
fully compatible with the original bitcoind/bitcoin-qt.  There are a few key
differences between hcd and bitcoind as far as how RPCs are serviced:
* Unlike bitcoind that has the wallet and chain intermingled in the same process
  which leads to several issues, hcd intentionally splits the wallet and chain
  services into independent processes.  See the blog post
  [here](https://blog.conformal.com/btcd-not-your-moms-bitcoin-daemon/) for
  further details on why they were separated.  This means that if you are
  talking directly to hcd, only chain-related RPCs are available.  However both
  chain-related and wallet-related RPCs are available via
  [hcwallet](https://github.com/james-ray/hcwallet).
* hcd is secure by default which means that the RPC connection is TLS-enabled
  by default
* hcd provides access to the API through both
  [HTTP POST](http://en.wikipedia.org/wiki/POST_%28HTTP%29) requests and
  [Websockets](http://en.wikipedia.org/wiki/WebSocket)

Websockets are the preferred transport for hcd RPC and are used by applications
such as [hcwallet](https://github.com/james-ray/hcwallet) for inter-process
communication with hcd.  The websocket connection endpoint for hcd is
`wss://your_ip_or_domain:14009/ws`.

In addition to the [standard API](#Methods), an [extension API](#WSExtMethods)
has been developed that is exclusive to clients using Websockets. In its current
state, this API attempts to cover features found missing in the standard API
during the development of hcwallet.

While the [standard API](#Methods) is stable, the
[Websocket extension API](#WSExtMethods) should be considered a work in
progress, incomplete, and susceptible to changes (both additions and removals).

The original bitcoind/bitcoin-qt JSON-RPC API documentation is available at [https://en.bitcoin.it/wiki/Original_Bitcoin_client/API_Calls_list](https://en.bitcoin.it/wiki/Original_Bitcoin_client/API_Calls_list)

<a name="HttpPostVsWebsockets" />

### 2. HTTP POST Versus Websockets

The hcd RPC server supports both [HTTP POST](http://en.wikipedia.org/wiki/POST_%28HTTP%29)
requests and the preferred [Websockets](http://en.wikipedia.org/wiki/WebSocket).
All of the standard and extension methods described in
this documentation can be accessed through both. As the name
indicates, the [Websocket-specific extension](#WSExtMethods) methods can only be
accessed when connected via Websockets.

As mentioned in the [overview](#Overview), the websocket connection endpoint for
hcd is `wss://your_ip_or_domain:14009/ws`.

The most important differences between the two transports as it pertains to the
JSON-RPC API are:

|   |HTTP POST Requests|Websockets|
|---|------------------|----------|
|Allows multiple requests across a single connection|No|Yes|
|Supports asynchronous notifications|No|Yes|
|Scales well with large numbers of requests|No|Yes|

<a name="Authentication" />

### 3. Authentication

<a name="AuthenticationOverview" />

**3.1 Authentication Overview**<br />

The following authentication details are needed before establishing a connection
to a hcd RPC server:

* **rpcuser** is the full-access username configured for the hcd RPC server
* **rpcpass** is the full-access password configured for the hcd RPC server
* **rpclimituser** is the limited username configured for the hcd RPC server
* **rpclimitpass** is the limited password configured for the hcd RPC server
* **rpccert** is the PEM-encoded X.509 certificate (public key) that the hcd
  server is configured with.  It is automatically generated by hcd and placed
  in the hcd home directory (which is typically `%LOCALAPPDATA%\Hcd` on
  Windows and `~/.hcd` on POSIX-like OSes)

**NOTE:** As mentioned above, hcd is secure by default which means the RPC
server is not running unless configured with a **rpcuser** and **rpcpass**
and/or a **rpclimituser** and **rpclimitpass**, and uses TLS authentication for
all connections.

Depending on which connection type you are using, you can choose one of
two, mutually exclusive, methods.
- [Use HTTP Authorization Header](#HTTPAuth) - HTTP POST requests and Websockets
- [Use the JSON-RPC "authenticate" command](#JSONAuth) - Websockets only

<a name="HTTPAuth" />

**3.2 HTTP Basic Access Authentication**<br />

The hcd RPC server uses HTTP [basic access authentication](http://en.wikipedia.org/wiki/Basic_access_authentication) with the **rpcuser**
and **rpcpass** detailed above.  If the supplied credentials are invalid, you
will be disconnected immediately upon making the connection.

<a name="JSONAuth" />

**3.3 JSON-RPC Authenticate Command (Websocket-specific)**<br />

While the HTTP basic access authentication method is the preferred method, the
ability to set HTTP headers from websockets is not always available.  In that
case, you will need to use the [authenticate](#authenticate) JSON-RPC method.

The [authenticate](#authenticate) command must be the first command sent after
connecting to the websocket.  Sending any other commands before authenticating,
supplying invalid credentials, or attempting to authenticate again when already
authenticated will cause the websocket to be closed immediately.


<a name="CLIUtil" />

### 4. Command-line Utility

hcd comes with a separate utility named `hcctl` which can be used to issue
these RPC commands via HTTP POST requests to hcd after configuring it with the
information in the [Authentication](#Authentication) section above.  It can also
be used to communicate with any server/daemon/service which provides a JSON-RPC
API compatible with the original hcd client.

<a name="Methods" />

### 5. Standard Methods

<a name="MethodOverview" />

**5.1 Method Overview**<br />

The following is an overview of the RPC methods and their current status.  Click
the method name for further details such as parameter and return information.

|#|Method|Safe for limited user?|Description|
|---|------|----------|-----------|
|1|[addnode](#addnode)|N|Attempts to add or remove a persistent peer.|
|2|[createrawtransaction](#createrawtransaction)|Y|Returns a new transaction spending the provided inputs and sending to the provided addresses.|
|3|[decoderawtransaction](#decoderawtransaction)|Y|Returns a JSON object representing the provided serialized, hex-encoded transaction.|
|4|[decodescript](#decodescript)|Y|Returns a JSON object with information about the provided hex-encoded script.|
|5|[getaddednodeinfo](#getaddednodeinfo)|N|Returns information about manually added (persistent) peers.|
|6|[getbestblockhash](#getbestblockhash)|Y|Returns the hash of the of the best (most recent) block in the longest block chain.|
|7|[getblock](#getblock)|Y|Returns information about a block given its hash.|
|8|[getblockcount](#getblockcount)|Y|Returns the number of blocks in the longest block chain.|
|9|[getblockhash](#getblockhash)|Y|Returns hash of the block in best block chain at the given height.|
|10|[getblockheader](#getblockheader)|Y|Returns the block header of the block.|
|11|[getconnectioncount](#getconnectioncount)|N|Returns the number of active connections to other peers.|
|12|[getdifficulty](#getdifficulty)|Y|Returns the proof-of-work difficulty as a multiple of the minimum difficulty.|
|13|[getgenerate](#getgenerate)|N|Return if the server is set to generate coins (mine) or not.|
|14|[gethashespersec](#gethashespersec)|N|Returns a recent hashes per second performance measurement while generating coins (mining).|
|15|[getinfo](#getinfo)|Y|Returns a JSON object containing various state info.|
|16|[getmempoolinfo](#getmempoolinfo)|N|Returns a JSON object containing mempool-related information.|
|17|[getmininginfo](#getmininginfo)|N|Returns a JSON object containing mining-related information.|
|18|[getnettotals](#getnettotals)|Y|Returns a JSON object containing network traffic statistics.|
|19|[getnetworkhashps](#getnetworkhashps)|Y|Returns the estimated network hashes per second for the block heights provided by the parameters.|
|20|[getpeerinfo](#getpeerinfo)|N|Returns information about each connected network peer as an array of json objects.|
|21|[getrawmempool](#getrawmempool)|Y|Returns an array of hashes for all of the transactions currently in the memory pool.|
|22|[getrawtransaction](#getrawtransaction)|Y|Returns information about a transaction given its hash.|
|23|[getwork](#getwork)|N|Returns formatted hash data to work on or checks and submits solved data.<br /><font color="orange">NOTE: Since hcd does not have the wallet integrated to provide payment addresses, hcd must be configured via the `--miningaddr` option to provide which payment addresses to pay created blocks to for this RPC to function.</font>|
|24|[help](#help)|Y|Returns a list of all commands or help for a specified command.|
|25|[ping](#ping)|N|Queues a ping to be sent to each connected peer.|
|26|[sendrawtransaction](#sendrawtransaction)|Y|Submits the serialized, hex-encoded transaction to the local peer and relays it to the network.<br /><font color="orange">hcd does not yet implement the `allowhighfees` parameter, so it has no effect</font>|
|27|[setgenerate](#setgenerate) |N|Set the server to generate coins (mine) or not.<br/>NOTE: Since hcd does not have the wallet integrated to provide payment addresses, hcd must be configured via the `--miningaddr` option to provide which payment addresses to pay created blocks to for this RPC to function.|
|28|[stop](#stop)|N|Shutdown hcd.|
|29|[submitblock](#submitblock)|Y|Attempts to submit a new serialized, hex-encoded block to the network.|
|30|[validateaddress](#validateaddress)|Y|Verifies the given address is valid.  NOTE: Since hcd does not have a wallet integrated, hcd will only return whether the address is valid or not.|
|31|[verifychain](#verifychain)|N|Verifies the block chain database.|
|32|[debuglevel](#debuglevel)|N|Dynamically changes the debug logging level.|
|33|[getbestblock](#getbestblock)|Y|Get block height and hash of best block in the main chain.|
|34|[getcurrentnet](#getcurrentnet)|Y|Get HC network hcd is running on.|
|35|[searchrawtransactions](#searchrawtransactions)|Y|Query for transactions related to a particular address.|
|36|[node](#node)|N|Attempts to add or remove a peer. |
|37|[generate](#generate)|N|When in simnet or regtest mode, generate a set number of blocks. |
|38|[getstakeversions](#getstakeversions)|Y|Get stake versions per block. |

<a name="MethodDetails" />

**5.2 Method Details**<br />

<a name="addnode"/>

|   |   |
|---|---|
|Method|addnode|
|Parameters|1. `peer`: `(string, required)` ip address and port of the peer to operate on.<br />2. `command`: `(string, required)` - `add` to add a persistent peer, `remove` to remove a persistent peer, or `onetry` to try a single connection to a peer.|
|Description|Attempts to add or remove a persistent peer.|
|Returns|Nothing|
[Return to Overview](#MethodOverview)<br />

***
<a name="createrawtransaction"/>

|   |   |
|---|---|
|Method|createrawtransaction|
|Parameters|1. transaction inputs (JSON array, required) - json array of json objects<br /></br>`hash`: (string, required) the hash of the input</br> `vout`: (numeric, required) the specific output of the input transaction to redeem transaction<br />`[{"txid": "hash", "vout": n}, ...]`<br /><br />2. addresses and amounts (JSON object, required) - json object with addresses as keys and amounts as values</br></br>`address`: (numeric, required) the address to send to as the key and the amount in HC as the value<br />`{"address": n.nnn, ...}`|
|Description|Returns a new transaction spending the provided inputs and sending to the provided addresses.The transaction inputs are not signed in the created transaction.<br /><br />The `signrawtransaction` RPC command provided by wallet must be used to sign the resulting transaction.|
|Returns|`"transaction" (string) hex-encoded bytes of the serialized transaction`|
|Example Parameters|1. transaction inputs `[{"txid":"e6da89de7a6b8508ce8f371a3d0535b04b5e108cb1a6e9284602d3bfd357c018", "vout":1}]`<br /><br />2. addresses and amounts ```{"13cgrTP7wgbZYWrY9BZ22BV6p82QXQT3nY": 0.49213337}```|
|Example Return|Newlines added for display purposes.  The actual return does not contain newlines.<br />`010000000118c057d3bfd3024628e9a6b18c105e4bb035053d1a378fce08856b7ade89dae6010000`<br />`0000ffffffff0199efee02000000001976a9141cb013db35ecccc156fdfd81d03a11c51998f99388`<br />`ac00000000`|
[Return to Overview](#MethodOverview)<br />

***
<a name="decoderawtransaction"/>

|   |   |
|---|---|
|Method|decoderawtransaction|
|Parameters|1. `data`: `(string, required)` serialized, hex-encoded transaction.|
|Description|Returns a JSON object representing the provided serialized, hex-encoded transaction.|
|Returns|`(json object)`<br />`hash`: (string) the hash of the transaction <br /> `locktime`: (numeric) the transaction lock time<br />`vin`: (array of json objects) the transaction inputs as json objects<br />`vout`: (array of json objects) the transaction outputs as json objects<br />`{"txid": "hash", "locktime": n, "vin": [...], "vout": [...]}`<br /><br /><font color="orange">Vin (for coinbase transactions): </font><br /><br />`(json object)`<br /> `coinbase`: (string) the hex-encoded bytes of the signature script<br />`sequence`: (numeric) the script sequence number<br />`{"coinbase": "data", "sequence": n}`<br /><br /><font color="orange">Vin (for non-coinbase transactions):</font><br /><br />`(json object)`<br />`txid`: (string) the hash of the origin transaction<br />`vout`: (numeric) the index of the output being redeemed from the origin transaction<br />`scriptSig`: the signature script used to redeem the origin transaction<br />`asm`:(string) disassembly of the script<br />`data`: (string) hex-encoded bytes of the script<br />`sequence`:  (numeric) the script sequence number<br />`{"txid": "hash", "vout": n,"scriptSig": {"asm": "asm", "hex": "data"}, "sequence": n}`<br /><br /><font color="orange">Vout:</font><br /><br />`(json object)`<br />`value`: (numeric) the value in HC<br />`n`: (numeric) the index of this transaction output<br />`scriptPubKey`:(json object) the public key script used to pay coins<br />`asm`: (string) disassembly of the script<br /> `hex`: (string) hex-encoded bytes of the script<br /> `reqSigs`: (numeric) the number of required signatures<br />`type`: (string) the type of the script (e.g. 'pubkeyhash')<br />`addresses`: (json array of string) the hc addresses associated with this output<br />`{ "value": n, "n": n, "scriptPubKey": {"asm": "asm", "hex": "data","reqSigs": n, "type": "scripttype","addresses": [...]}}`|
|Example Return|<font color="orange">For coinbase transactions:</font><br /><br />`{"txid": "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b", "version": 1, "locktime": 0, "vin": [{"coinbase": "04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6...","sequence": 4294967295}, ...],"vout": [{"value": 50, "n": 0, "scriptPubKey": {"asm": "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4ce...","hex": "4104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4...", "reqSigs": 1,"type": "pubkey","addresses": ["1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa", ...]}}]}`<br /><br /><font color="orange">For non-coinbase transactions:</font><br /><br />`{"txid": "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b", "version": 1, "locktime": 0, "vin": [{"txid": "60ac4b057247b3d0b9a8173de56b5e1be8c1d1da970511c626ef53706c66be04", "vout": 0, "scriptSig": {"asm": "3046022100cb42f8df44eca83dd0a727988dcde9384953e830b1f8004d57485e2ede1b9c8f0...", "hex": "493046022100cb42f8df44eca83dd0a727988dcde9384953e830b1f8004d57485e2ede1b9c8...",},"sequence": 4294967295}, ...],"vout": [{"value": 50, "n": 0, "scriptPubKey": {"asm": "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4ce...","hex": "4104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4...", "reqSigs": 1,"type": "pubkey","addresses": ["1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa", ...]}}]}`|
[Return to Overview](#MethodOverview)<br />
***
<a name="decodescript"/>

|   |   |
|---|---|
|Method|decodescript|
|Parameters|1. `script`: `(string, required)` hex-encoded script.|
|Description|Returns a JSON object with information about the provided hex-encoded script.|
|Returns|`(json object)`<br />`asm`: (string) disassembly of the script<br />`reqSigs`: (numeric) the number of required signatures<br />`type`: (string) the type of the script (e.g. 'pubkeyhash')<br />`addresses`: (json array of string) the hc addresses associated with this script<br />`p2sh`: (string) the script hash for use in pay-to-script-hash transactions<br />`{ "asm": "asm", "reqSigs": n, "type": "scripttype", "addresses": [...], "p2sh": "scripthash"}`|
|Example Return|`{"asm": "OP_DUP OP_HASH160 b0a4d8a91981106e4ed85165a66748b19f7b7ad4 OP_EQUALVERIFY OP_CHECKSIG", "reqSigs": 1, "type": "pubkeyhash", "addresses": ["1H71QVBpzuLTNUh5pewaH3UTLTo2vWgcRJ"], "p2sh": "359b84ff799f48231990ff0298206f54117b08b6"}`|
[Return to Overview](#MethodOverview)<br />

***
<a name="getaddednodeinfo"/>

|   |   |
|---|---|
|Method|getaddednodeinfo|
|Parameters|1. `dns`: `(boolean, required)` specifies whether the returned data is a JSON object including DNS and connection information, or just a list of added peers.<br />2. `node`: `(string, optional)` only return information about this specific peer instead of all added peers.|
|Description|Returns information about manually added (persistent) peers.|
|Returns (dns=false)|`["ip:port", ...]`|
|Returns (dns=true)|`(json array of objects)`<br />`addednode`: `(string)` the ip address or domain of the added peer.<br />`connected`: `(boolean)` whether or not the peer is currently connected.<br />`addresses`: `(json array or objects)` DNS lookup and connection information about the peer.<br />`address`: `(string)` the ip address for this DNS entry.<br />`connected`: `(string)` the connection 'direction' (if connected).<br /><br />`[{"addednode": "ip_or_domain","connected": true or false,"addresses": [{address: "ip"}, ...], "connected": "inbound/outbound/false"}, ...]`|
|Example Return (dns=false)|`["192.168.0.10:9108", "mydomain.org:9108"]`|
|Example Return (dns=true)|`[{"addednode": "mydomain.org:9108", "connected": true, "addresses": [{"address": "1.2.3.4", "connected": "outbound"}, {"address": "5.6.7.8", "connected": "false"}]}]`|
[Return to Overview](#MethodOverview)<br />

***
<a name="getbestblockhash"/>

|   |   |
|---|---|
|Method|getbestblockhash|
|Parameters|None|
|Description|Returns the hash of the of the best (most recent) block in the longest block chain.|
|Returns|`string`|
|Example Return|`0000000000000001f356adc6b29ab42b59f913a396e170f80190dba615bd1e60`|
[Return to Overview](#MethodOverview)<br />

***
<a name="getblock"/>

|   |   |
|---|---|
|Method|getblock|
|Parameters|1. block hash (string, required) - the hash of the block<br />2. verbose (boolean, optional, default=true) - specifies the block is returned as a JSON object instead of hex-encoded string<br />3. verbosetx (boolean, optional, default=false) - specifies that each transaction is returned as a JSON object and only applies if the `verbose` flag is true.<font color="orange">**This parameter is a hcd extension**</font>|
|Description|Returns information about a block given its hash.|
|Returns (verbose=false)|`"data" (string) hex-encoded bytes of the serialized block`|
|Returns (verbose=true, verbosetx=false)| `(json object)`<br />`hash`: `(string)` the hash of the block (same as provided).<br />`confirmations`: `(numeric)` the number of confirmations.<br />`size`: `(numeric)` the size of the block.<br />`height`: `(numeric)` the height of the block in the block chain.<br />`version`: `(numeric)` the block version.<br />`merkleroot`: (string) root hash of the merkle tree.<br />`stakeroot`: `(string)` root hash of the stake tree.<br />`tx`: `(json array of string)` the transaction hashes.<br />`stx`: `(json array of string)` the stake transaction hashes.<br />`transactionhash`: `(string)` hash of the parent transaction.<br />`time`: `(numeric)` the block time in seconds since 1 Jan 1970 GMT.<br />`nonce`: `(numeric)` the block nonce.<br />`bits`: `(numeric)` the bits which represent the block difficulty.<br />`sbits`: `(numeric)` the bits which represent the stake difficulty<br />`revocations`: `(numeric)` the number of nullified tickets.<br />`difficulty`: `(numeric)` the proof-of-work difficulty as a multiple of the minimum difficulty.<br />`previousblockhash`: `(string)` the hash of the previous block.<br />`nextblockhash`: `(string)` the hash of the next block.<br /><br />`{"hash": "blockhash","confirmations": n, "size": n, "height": n,"version": n, "merkleroot": "hash","tx": ["transactionhash", ...],"stx": ["transactionhash", ...],"time": n, "revocations": n, "nonce": n,  "bits": n, "difficulty": n.nn, "previousblockhash": "hash", "nextblockhash": "hash", ...}`
|Returns (verbose=true, verbosetx=true)|`(json object)`<br />`hash`: (string) the hash of the block (same as provided)<br />`confirmations`: `(numeric)` the number of confirmations.<br />`size`: `(numeric)` the size of the block.<br />`height`: `(numeric)` the height of the block in the block chain.<br />`version`: `(numeric)` the block version.<br />`merkleroot`: `(string)` root hash of the merkle tree.<br />`rawtx`: `(array of json objects)` the transactions as json objects.<br />`tx`: `(json array of string)` the transaction hashes.<br />`stx`: `(json array of string)` the stake transaction hashes.<br />`transactionhash`: `(string)` hash of the parent transaction.<br />`time`: `(numeric)` the block time in seconds since 1 Jan 1970 GMT.<br />`nonce`: `(numeric)` the block nonce.<br />`bits`: `(numeric)` the bits which represent the block difficulty.<br />`revocations`: `(numeric)` the number of nullified tickets.<br />`difficulty`: `(numeric)` the proof-of-work difficulty as a multiple of the minimum difficulty.<br />`previousblockhash`: `(string)` the hash of the previous block.<br />`nextblockhash`: `(string)` the hash of the next block.<br /><br />`{"hash": "blockhash","confirmations": n, "size": n, "height": n,"version": n, "merkleroot": "hash", "rawtx":[...], "tx": ["transactionhash", ...], "tx": ["transactionhash", ...],"time": n, "revocations": n, "nonce": n,  "bits": n, "difficulty": n.nn, "previousblockhash": "hash", "nextblockhash": "hash", ...}`|
|Example Return (verbose=false)|Newlines added for display purposes. The actual return does not contain newlines.<br/> `"010000000000000000000000000000000000000000000000000000000000000000000000`<br />`3ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab5f49`<br />`ffff001d1dac2b7c01010000000100000000000000000000000000000000000000000000`<br />`00000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f`<br />`4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f`<br />`6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104`<br />`678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f`<br />`4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000"`<br />|
|Example Return (verbose=true, verbosetx=false)|`"hash": "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f", "confirmations": 277113,"size": 285, "height": 0, "version": 1, "merkleroot": "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b", "tx": ["4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b", ...], "stx": ["4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f", ...], "time": 1231006505, "nonce": 2083236893, "bits": "1d00ffff", "difficulty": 1, "previousblockhash": "0000000000000000000000000000000000000000000000000000000000000000", "nextblockhash": "00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048", ...}`|
[Return to Overview](#MethodOverview)<br />

***
<a name="getblockcount"/>

|   |   |
|---|---|
|Method|getblockcount|
|Parameters|None|
|Description|Returns the number of blocks in the longest block chain.|
|Returns|numeric|
|Example Return|`276820`|
[Return to Overview](#MethodOverview)<br />

***
<a name="getblockhash"/>

|   |   |
|---|---|
|Method|getblockhash|
|Parameters|1. block height (numeric, required)|
|Description|Returns hash of the block in best block chain at the given height.|
|Returns|string|
|Example Return|`000000000000000096579458d1c0f1531fcfc58d57b4fce51eb177d8d10e784d`|
[Return to Overview](#MethodOverview)<br />

***
<a name="getblockheader"/>

|   |   |
|---|---|
|Method|getblockheader|
|Parameters|1.  `block hash`: `(string, required)` the hash of the block.<br />2. `verbose`: `(boolean, optional, default=true)` specifies the block header is returned as a JSON object instead of a hex-encoded string.|
|Description|Returns hex-encoded bytes of the serialized block header.|
|Returns (verbose=false)|`"data" (string) hex-encoded bytes of the serialized block`|
|Returns (verbose=true)|`(json object)`<br />`hash`: `(string)` the hash of the block (same as provided).<br />`confirmations`: `(numeric)` the number of confirmations.<br />`height`: `(numeric)` the height of the block in the block chain.<br />`version`: `(numeric)` the block version.<br />`merkleroot`:  `(string)` root hash of the merkle tree.<br />`stakeroot`:  `(string)` root hash of the stake tree.<br />`time`: `(numeric)` the block time in seconds since 1 Jan 1970 GMT<br />`nonce`: (numeric) the block nonce.<br />`bits`: `(numeric)` the bits which represent the block difficulty.<br />`sbits`: `(numeric)` the bits which represent the stake difficulty.<br />`difficulty`: `(numeric)` the proof-of-work difficulty as a multiple of the minimum difficulty.<br />`previousblockhash`: `(string)` the hash of the previous block.<br />`nextblockhash`: `(string)` the hash of the next block (only if there is one).<br /><br />`{"hash": "blockhash", "confirmations": n, "height": n, "version": n,  "merkleroot": "hash", "stakeroot": "hash", "time": n, "nonce": n, "bits": n, "sbits": n, "difficulty": n.nn,  "previousblockhash": "hash", "nextblockhash": "hash"}`|
|Example Return (verbose=false)|Newlines added for display purposes.  The actual return does not contain newlines.<br />`"0200000035ab154183570282ce9afc0b494c9fc6a3cfea05aa8c1add2ecc564900000000`<br />`38ba3d78e4500a5a7570dbe61960398add4410d278b21cd9708e6d9743f374d544fc0552`<br />`27f1001c29c1ea3b"`|
|Example Return (verbose=true)|`{"hash": "00000000009e2958c15ff9290d571bf9459e93b19765c6801ddeccadbb160a1e", "confirmations": 392076, "height": 100000, "version": 2, "merkleroot": "d574f343976d8e70d91cb278d21044dd8a396019e6db70755a0a50e4783dba38", "stakeroot":"b4765ae7d5bf4768ff7c4372d55abb7894b2bd9d3f48f7437115502b0bcc47e7", "time": 1376123972, "nonce": 1005240617, "bits": "1c00f127", "sbits": 68, "difficulty": 271.75767393, "previousblockhash": "000000004956cc2edd1a8caa05eacfa3c69f4c490bfc9ace820257834115ab35",  "nextblockhash": "0000000000629d100db387f37d0f37c51118f250fb0946310a8c37316cbc4028", ...}`|
[Return to Overview](#MethodOverview)<br />

***
<a name="getconnectioncount"/>

|   |   |
|---|---|
|Method|getconnectioncount|
|Parameters|None|
|Description|Returns the number of active connections to other peers.|
|Returns|numeric|
|Example Return|`8`|
[Return to Overview](#MethodOverview)<br />

***
<a name="getdifficulty"/>

|   |   |
|---|---|
|Method|getdifficulty|
|Parameters|None|
|Description|Returns the proof-of-work difficulty as a multiple of the minimum difficulty.|
|Returns|numeric|
|Example Return|`1180923195.260000`|
[Return to Overview](#MethodOverview)<br />

***
<a name="getgenerate"/>

|   |   |
|---|---|
|Method|getgenerate|
|Parameters|None|
|Description|Return if the server is set to generate coins (mine) or not.|
|Returns|`false` (boolean)|
[Return to Overview](#MethodOverview)<br />

***
<a name="gethashespersec"/>

|   |   |
|---|---|
|Method|gethashespersec|
|Parameters|None|
|Description|Returns a recent hashes per second performance measurement while generating coins (mining).|
|Returns|`0` (numeric)|
[Return to Overview](#MethodOverview)<br />

***
<a name="getinfo"/>

|   |   |
|---|---|
|Method|getinfo|
|Parameters|None|
|Description|Returns a JSON object containing various state info.|
|Notes|NOTE: Since hcd does NOT contain wallet functionality, wallet-related fields are not returned.  See getinfo in hcwallet for a version which includes that information.|
|Returns|`(json object)`<br />`version`: (numeric) the version of the server<br />`protocolversion`: (numeric) the latest supported protocol version<br />`blocks`: (numeric) the number of blocks processed<br />`timeoffset`: (numeric) the time offset<br />`connections`: (numeric) the number of connected peers<br />`proxy`: (string) the proxy used by the server<br />`difficulty`: (numeric) the current target difficulty<br />`testnet`: (boolean) whether or not server is using testnet<br />`relayfee`: (numeric) the minimum relay fee for non-free transactions in HC/KB<br />`{"version": n,"protocolversion": n, "blocks": n, "timeoffset": n, "connections": n, "proxy": "host:port", "difficulty": n.nn, "testnet": true or false, "relayfee": n.nn}`|
| Example Return |`{"version": 70000, "protocolversion": 70001, "blocks": 298963, "timeoffset": 0, "connections": 17, "proxy": "", "difficulty": 8000872135.97, "testnet": false,"relayfee": 0.00001}`|
[Return to Overview](#MethodOverview)<br />
***
<a name="getmempoolinfo"/>

|   |   |
|---|---|
|Method|getmempoolinfo|
|Parameters|None|
|Description|Returns a JSON object containing mempool-related information.|
|Returns|`(json object)`<br />`bytes`: `(numeric)` size in bytes of the mempool<br />`size`: `(numeric)` number of transactions in the mempool<br /><br />`{"bytes": n, "size": n}`
|Example Return|`{"bytes": 310768, "size": 157}`|
[Return to Overview](#MethodOverview)<br />

***
<a name="getmininginfo"/>

|   |   |
|---|---|
|Method|getmininginfo|
|Parameters|None|
|Description|Returns a JSON object containing mining-related information.|
|Returns|`(json object)`<br />`blocks`: `(numeric)` latest best block.<br />`currentblocksize`: `(numeric)` size of the latest best block.<br />`currentblocktx`: `(numeric)` number of transactions in the latest best block.<br />`difficulty`: `(numeric)` current target difficulty.<br />`stakedifficulty`: `(numeric)` Stake difficulty required for the next block.<br />`errors`: `(string)` any current errors.<br />`generate`: `(boolean)` whether or not server is set to generate coins.<br />`genproclimit`:  `(numeric)` number of processors to use for coin generation (-1 when disabled).<br />`hashespersec`: `(numeric)` recent hashes per second performance measurement while generating coins.<br />`networkhashps`: `(numeric)` estimated network hashes per second for the most recent blocks.<br />`pooledtx`:  `(numeric)` number of transactions in the memory pool.<br />`testnet`: `(boolean)` whether or not server is using testnet.<br /><br />`{"blocks": n, "currentblocksize": n, "currentblocktx": n, "difficulty": n.nn,  "stakedifficulty": n, "errors": "errors", "generate": true or false,  "genproclimit": n, "hashespersec": n, "networkhashps": n, "pooledtx": n,  "testnet": true or false }`|
|Example Return|`{"blocks": 236526, "currentblocksize": 185, "currentblocktx": 1, "difficulty": 256, "errors": "", "generate": false, "genproclimit": -1, "hashespersec": 0, "networkhashps": 33081554756, "pooledtx": 8, "testnet": true }`|
[Return to Overview](#MethodOverview)<br />

***
<a name="getnettotals"/>

|   |   |
|---|---|
|Method|getnettotals|
|Parameters|None|
|Description|Returns a JSON object containing network traffic statistics.|
|Returns|`(json object)`<br />`totalbytesrecv`: `(numeric)` total bytes received.<br />`totalbytessent`: `(numeric)` total bytes sent.<br />`timemillis`: `(numeric)` number of milliseconds since 1 Jan 1970 GMT.<br /><br />`{"totalbytesrecv": n, "totalbytessent": n, "timemillis": n }`|
|Example Return|`{"totalbytesrecv": 1150990, "totalbytessent": 206739, "timemillis": 1391626433845 }`|
[Return to Overview](#MethodOverview)<br />

***
<a name="getnetworkhashps"/>

|   |   |
|---|---|
|Method|getnetworkhashps|
|Parameters|1. `blocks`: `(numeric, optional, default=120)` The number of blocks, or -1 for blocks since last difficulty change.<br />2. `height`: `(numeric, optional, default=-1)` Perform estimate ending with this height or -1 for current best chain block height.|
|Description|Returns the estimated network hashes per second for the block heights provided by the parameters.|
|Returns|numeric|
|Example Return|`6573971939`|
[Return to Overview](#MethodOverview)<br />

***
<a name="getpeerinfo"/>

|   |   |
|---|---|
|Method|getpeerinfo|
|Parameters|None|
|Description|Returns data about each connected network peer as an array of json objects.|
|Returns|`(json array)`<br />`addr`: (string) the ip address and port of the peer<br />`services`: (string) the services supported by the peer<br />`lastrecv`: (numeric) time the last message was received in seconds since 1 Jan 1970 GMT<br />`lastsend`: (numeric) time the last message was sent in seconds since 1 Jan 1970 GMT<br />`bytessent`: (numeric) total bytes sent<br />`bytesrecv`:  (numeric) total bytes received<br />`conntime`: (numeric) time the connection was made in seconds since 1 Jan 1970 GMT<br />`pingtime`: (numeric) number of microseconds the last ping took<br />`pingwait`: (numeric) number of microseconds a queued ping has been waiting for a response<br />`version`: (numeric) the protocol version of the peer<br />`subver`: (string) the user agent of the peer<br />`inbound`: (boolean) whether or not the peer is an inbound connection<br />`startingheight`: (numeric) the latest block height the peer knew about when the connection was established<br />`currentheight`: (numeric) the latest block height the peer is known to have relayed since connected<br />`syncnode`: (boolean) whether or not the peer is the sync peer<br />`[{"addr": "host:port", "services": "00000001", "lastrecv": n, "lastsend": n,  "bytessent": n, "bytesrecv": n, "conntime": n, "pingtime": n, "pingwait": n,  "version": n, "subver": "useragent", "inbound": true_or_false, "startingheight": n, "currentheight": n, "syncnode": true_or_false }, ...]`|
|Example Return|`[{"addr": "178.172.xxx.xxx:9108", "services": "00000001", "lastrecv": 1388183523, "lastsend": 1388185470, "bytessent": 287592965, "bytesrecv": 780340, "conntime": 1388182973, "pingtime": 405551, "pingwait": 183023, "version": 70001, "subver": "/hcd:0.4.0/", "inbound": false, "startingheight": 276921, "currentheight": 276955, "syncnode": true }, ...]`|
[Return to Overview](#MethodOverview)<br />

***
<a name="getrawtransaction"/>

|   |   |
|---|---|
|Method|getrawtransaction|
|Parameters|1. `transaction hash`: `(string, required)` the hash of the transaction.<br />2. `verbose`: `(int, optional, default=0)` specifies the transaction is returned as a JSON object instead of hex-encoded string.|
|Description|Returns information about a transaction given its hash.|
|Returns (verbose=0)|`"data" (string) hex-encoded bytes of the serialized transaction`|
|Returns (verbose=1)|`(json object)`<br />`hex`: (string) hex-encoded transaction<br />`txid`: (string) the hash of the transaction<br />`version`: (numeric) the transaction version<br />`locktime`: (numeric) the transaction lock time<br />`vin`: (array of json objects) the transaction inputs as json objects<br />`coinbase`: (string) the hex-encoded bytes of the signature script<br />`sequence`: (numeric) the script sequence number<br />`txid`: (string) the hash of the origin transaction<br />`vout`: (numeric) the index of the output being redeemed from the origin transaction<br />`scriptSig`: (json object) the signature script used to redeem the origin transaction<br />`asm`: (string) disassembly of the script<br />`hex`: (string) hex-encoded bytes of the script<br />`sequence`: (numeric) the script sequence number<br />`vout`: (array of json objects) the transaction outputs as json objects<br />`value`: (numeric) the value in BTC<br />`n`: (numeric) the index of this transaction output<br />`scriptPubKey`: the public key script used to pay coins<br />`asm`: (string) disassembly of the script<br />`hex`: (string) hex-encoded bytes of the script<br />`reqSigs`: (numeric) the number of required signatures<br />`type`: (string) the type of the script (e.g. 'pubkeyhash')<br />`addresses`: (json array of string) the hc addresses associated with this output<br />`hcaddress`:  (string) the hc address<br /><br /><font color="orange">For coinbase transactions:</font><br /><br />`{"hex": "data", "txid": "hash", "version": n, "locktime": n, "vin": [{ "coinbase": "data", "sequence": n}, ...], "vout": [{"value": n, "n": n,"scriptPubKey": { "asm": "asm","hex": "data", "reqSigs": n,"type": "scripttype", "addresses": [ "hcaddress", ...]}}, ...]}`<br /><br /><font color="orange">For non-coinbase transactions:</font><br /><br />`{"hex": "data", "txid": "hash", "version": n, "locktime": n, "vin": [{"txid": "hash","vout": n, "scriptSig": {"asm": "asm", "hex": "data"}, "sequence": n}, ...], "vout": [{"value": n, "n": n,"scriptPubKey": { "asm": "asm","hex": "data", "reqSigs": n,"type": "scripttype", "addresses": [ "hcaddress", ...]}}, ...]}`|
|Example Return (verbose=0)|`"010000000104be666c7053ef26c6110597dad1c1e81b5e6be53d17a8b9d0b34772054bac60000000`<br />`008c493046022100cb42f8df44eca83dd0a727988dcde9384953e830b1f8004d57485e2ede1b9c8f`<br />`022100fbce8d84fcf2839127605818ac6c3e7a1531ebc69277c504599289fb1e9058df0141045a33`<br />`76eeb85e494330b03c1791619d53327441002832f4bd618fd9efa9e644d242d5e1145cb9c2f71965`<br />`656e276633d4ff1a6db5e7153a0a9042745178ebe0f5ffffffff0280841e00000000001976a91406`<br />`f1b6703d3f56427bfcfd372f952d50d04b64bd88ac4dd52700000000001976a9146b63f291c295ee`<br />`abd9aee6be193ab2d019e7ea7088ac00000000`<br /><font color="orange">Newlines added for display purposes.  The actual return does not contain newlines.</font>|
|Example Return (verbose=1)|<font color="orange">For coinbase transactions:</font><br /><br />`{"hex": "01000000010000000000000000000000000000000000000000000000000000000000000000f...","txid": "90743aad855880e517270550d2a881627d84db5265142fd1e7fb7add38b08be9","version": 1,"locktime": 0,"vin": [{"coinbase": "03708203062f503253482f04066d605108f800080100000ea2122f6f7a636f696e4065757374726174756d2f","sequence": 0},...], "vout": [{"value": 25.1394,"n": 0, "scriptPubKey": {"asm": "OP_DUP OP_HASH160 ea132286328cfc819457b9dec386c4b5c84faa5c OP_EQUALVERIFY OP_CHECKSIG", "hex": "76a914ea132286328cfc819457b9dec386c4b5c84faa5c88ac", "reqSigs": 1, "type": "pubkeyhash", "addresses": ["1NLg3QJMsMQGM5KEUaEu5ADDmKQSLHwmyh", ...]}}]}`<font color="orange"><br /><br />For non-coinbase transactions:</font><br /><br />`{"hex": "01000000010000000000000000000000000000000000000000000000000000000000000000f...","txid": "90743aad855880e517270550d2a881627d84db5265142fd1e7fb7add38b08be9","version": 1,"locktime": 0,"vin": [{"txid": "60ac4b057247b3d0b9a8173de56b5e1be8c1d1da970511c626ef53706c66be04","scriptSig": {"asm": "3046022100cb42f8df44eca83dd0a727988dcde9384953e830b1f8004d57485e2ede1b9c8f0...","hex": "493046022100cb42f8df44eca83dd0a727988dcde9384953e830b1f8004d57485e2ede1b9c8..."}, "sequence": 4294967295}, ...], "vout": [{"value": 25.1394,"n": 0, "scriptPubKey": {"asm": "OP_DUP OP_HASH160 ea132286328cfc819457b9dec386c4b5c84faa5c OP_EQUALVERIFY OP_CHECKSIG", "hex": "76a914ea132286328cfc819457b9dec386c4b5c84faa5c88ac", "reqSigs": 1, "type": "pubkeyhash", "addresses": ["1NLg3QJMsMQGM5KEUaEu5ADDmKQSLHwmyh", ...]}}]}`|
[Return to Overview](#MethodOverview)<br />

***
<a name="getwork"/>

|   |   |
|---|---|
|Method|getwork|
|Parameters|1. `data`: `(string, optional)` The hex|
|Description|Returns information about a transaction given its hash.|
|Notes|<font color="orange">NOTE: Since hcd does not have the wallet integrated to provide payment addresses, hcd must be configured via the `--miningaddr` option to provide which payment addresses to pay created blocks to for this RPC to function.</font>
|Returns (data not specified)|`(json object)`<br />`data`: (string) hex-encoded block data<br />`hash1`: (string)  (DEPRECATED) hex-encoded formatted hash buffer <br />`midstate`: (string) (DEPRECATED) hex-encoded precomputed hash state after hashing first half of the data <br />`target`: (string) the hex-encoded little-endian hash target<br />`{"data": "hex", "hash1": "hex", "midstate": "hex", "target": "hex"}`|
|Returns (data specified)|`true` or `false` (boolean)|
|Example Return (data not specified)|`{"data": "00000002c39b5d2b7a1e8f7356a1efce26b24bd15d7d906e85341ef9cec99b6a000000006474f...", "hash1": "00000000000000000000000000000000000000000000000000000000000000000000008000000...", "midstate": "ae4a80fc51476e452de855b4e20d5f33418c50fc7cae3b1ecd5badb819b8a584", "target": "0000000000000000000000000000000000000000000000008c96010000000000"}`|
|Example Return (data specified)|`true`|
[Return to Overview](#MethodOverview)<br />

***
<a name="help"/>

|   |   |
|---|---|
|Method|help|
|Parameters|1. `command`: `(string, optional)` the command to get help for|
|Description|Returns a list of all commands or help for a specified command.<br />When no `command` parameter is specified, a list of available commands is returned<br />When `command` is a valid method, the help text for that method is returned.|
|Returns|`string`|
|Example Return|getblockcount<br />Returns a numeric for the number of blocks in the longest block chain.|
[Return to Overview](#MethodOverview)<br />

***
<a name="ping"/>

|   |   |
|---|---|
|Method|ping|
|Parameters|None|
|Description|Queues a ping to be sent to each connected peer.<br />Ping times are provided by [getpeerinfo](#getpeerinfo) via the `pingtime` and `pingwait` fields.|
|Returns|Nothing|
[Return to Overview](#MethodOverview)<br />

***
<a name="getrawmempool"/>

|   |   |
|---|---|
|Method|getrawmempool|
|Parameters|1. `verbose` `(boolean, optional, default=false)`|
|Description|Returns an array of hashes for all of the transactions currently in the memory pool.<br />The `verbose` flag specifies that each transaction is returned as a JSON object.|
|Notes|<font color="orange">Since hcd does not perform any mining, the priority related fields `startingpriority` and `currentpriority` that are available when the `verbose` flag is set are always 0.</font>|
|Returns (verbose=false)|`(json array of string)`<br />`transactionhash`: (string) hash of the transaction<br />`["transactionhash", ...]`|
|Returns (verbose=true)|`(json object)`<br />`size`: (numeric) transaction size in bytes<br />`fee` : (numeric) transaction fee in hcs<br />`time`:  (numeric) local time transaction entered pool in seconds since 1 Jan 1970 GMT<br />"height": (numeric) block height when transaction entered the pool<br />`startingpriority`: (numeric) priority when transaction entered the pool<br />`currentpriority`: (numeric) current priority<br />`depends`:  (json array) unconfirmed transactions used as inputs for this transaction<br />`transactionhash`: (string) hash of the parent transaction<br />`{"transactionhash": {"size": n,"fee" : n, "time": n,"height": n, "startingpriority": n, "currentpriority": n, "depends": ["transactionhash", ...]}, ...}`|
|Example Return (verbose=false)|`["3480058a397b6ffcc60f7e3345a61370fded1ca6bef4b58156ed17987f20d4e7","cbfe7c056a358c3a1dbced5a22b06d74b8650055d5195c1c2469e6b63a41514a"]`|
|Example Return (verbose=true)|`{"1697a19cede08694278f19584e8dcc87945f40c6b59a942dd8906f133ad3f9cc": {"size": 226, "fee" : 0.0001, "time": 1387992789, "height": 276836, "startingpriority": 0, "currentpriority": 0, "depends": ["aa96f672fcc5a1ec6a08a94aa46d6b789799c87bd6542967da25a96b2dee0afb", ...]}`|
[Return to Overview](#MethodOverview)<br />

***
<a name="setgenerate"/>

|   |   |
|---|---|
|Method|setgenerate|
|Parameters|1. `generate`: `(boolean, required)` set to `true` to enable generation, `false` to disable it.<br />2. `genproclimit`: `(numeric, optional)` the number of processors (cores) to limit generation to or `-1` for default.|
|Description|Set the server to generate coins (mine) or not.|
|Notes|NOTE: Since hcd does not have the wallet integrated to provide payment addresses, hcd must be configured via the `--miningaddr` option to provide which payment addresses to pay created blocks to for this RPC to function.|
|Returns|Nothing|
[Return to Overview](#MethodOverview)<br />

***
<a name="sendrawtransaction"/>

|   |   |
|---|---|
|Method|sendrawtransaction|
|Parameters|1. `signedhex`: `(string, required)` serialized, hex-encoded signed transaction.<br />2. `allowhighfees`: `(boolean, optional, default=false)` whether or not to allow insanely high fees.|
|Description|Submits the serialized, hex-encoded transaction to the local peer and relays it to the network.|
|Notes|<font color="orange">hcd does not yet implement the `allowhighfees` parameter, so it has no effect</font>|
|Returns|`"hash" (string) the hash of the transaction`|
|Example Return|`"1697a19cede08694278f19584e8dcc87945f40c6b59a942dd8906f133ad3f9cc"`|
[Return to Overview](#MethodOverview)<br />

***
<a name="submitblock"/>

|   |   |
|---|---|
|Method|submitblock|
|Parameters|1. `data`: `(string, required)` serialized, hex-encoded block.<br />2. `params`: `(json object, optional, default=nil)` this parameter is currently ignored.|
|Description|Attempts to submit a new serialized, hex-encoded block to the network.|
|Returns|`Success`: Nothing.<br />`Failure`: `(string)` `"rejected: reason"`|
[Return to Overview](#MethodOverview)<br />

***
<a name="stop"/>

|   |   |
|---|---|
|Method|stop|
|Parameters|None|
|Description|Shutdown hcd.|
|Returns|`"hcd stopping."` (string)|
[Return to Overview](#MethodOverview)<br />

***
<a name="validateaddress"/>

|   |   |
|---|---|
|Method|validateaddress|
|Parameters|1. address (string, required) - hc address|
|Description|Verify an address is valid.|
|Returns|`(json object)`<br />`isvalid`: (bool) whether or not the address is valid.<br />`address`: (string) the hc address validated.<br />`{"isvalid": true or false,"address": "hcaddress"}`|
[Return to Overview](#MethodOverview)<br />

***
<a name="verifychain"/>

|   |   |
|---|---|
|Method|verifychain|
|Parameters|1. checklevel (numeric, optional, default=3) - how in-depth the verification is (0=least amount of checks, higher levels are clamped to the highest supported level)<br />2. numblocks (numeric, optional, default=288) - the number of blocks starting from the end of the chain to verify|
|Description|Verifies the block chain database.<br />The actual checks performed by the `checklevel` parameter is implementation specific.  For hcd this is:<br />`checklevel=0` - Look up each block and ensure it can be loaded from the database.<br />`checklevel=1` - Perform basic context-free sanity checks on each block.|
|Notes|<font color="orange">hcd currently only supports `checklevel` 0 and 1, but the default is still 3 for compatibility.  Per the information in the Parameters section above, higher levels are automatically clamped to the highest supported level, so this means the default is effectively 1 for hcd.</font>|
|Returns|`true` or `false` (boolean)|
|Example Return|`true`|
[Return to Overview](#MethodOverview)<br />

<a name="ExtensionMethods" />

### 6. Extension Methods

<a name="ExtMethodOverview" />

**6.1 Method Overview**<br />

The following is an overview of the RPC methods which are implemented by hcd, but not the original hcd client. Click the method name for further details such as parameter and return information.

|#|Method|Safe for limited user?|Description|
|---|------|----------|-----------|
|1|[debuglevel](#debuglevel)|N|Dynamically changes the debug logging level.|
|2|[getbestblock](#getbestblock)|Y|Get block height and hash of best block in the main chain.|None|
|3|[getcurrentnet](#getcurrentnet)|Y|Get hc network hcd is running on.|None|
|4|[searchrawtransactions](#searchrawtransactions)|Y|Query for transactions related to a particular address.|None|
|5|[node](#node)|N|Attempts to add or remove a peer. |None|
|6|[generate](#generate)|N|When in simnet or regtest mode, generate a set number of blocks. |None|
|7|[getstakeversions](#getstakeversions)|Y|Get stake versions per block. |None|


<a name="ExtMethodDetails" />

**6.2 Method Details**<br />

<a name="debuglevel"/>

|   |   |
|---|---|
|Method|debuglevel|
|Parameters|1. levelspec (string)|
|Description|Dynamically changes the debug logging level.<br />The levelspec can either a debug level or of the form `<subsystem>=<level>,<subsystem2>=<level2>,...`<br />The valid debug levels are `trace`, `debug`, `info`, `warn`, `error`, and `critical`.<br />The valid subsystems are `AMGR`, `ADXR`, `BCDB`, `BMGR`, `HC`, `CHAN`, `DISC`, `PEER`, `RPCS`, `SCRP`, `SRVR`, and `TXMP`.<br />Additionally, the special keyword `show` can be used to get a list of the available subsystems.|
|Returns|string|
|Example Return|`Done.`|
|Example `show` Return|`Supported subsystems [AMGR ADXR BCDB BMGR HC CHAN DISC PEER RPCS SCRP SRVR TXMP]`|
[Return to Overview](#ExtMethodOverview)<br />

***

<a name="getbestblock"/>

|   |   |
|---|---|
|Method|getbestblock|
|Parameters|None|
|Description|Get block height and hash of best block in the main chain.|
|Returns|`(json object)`<br />`hash`: `(string)` the hex-encoded bytes of the best block hash.<br />`height`: `(numeric)` the block height of the best block.<br /><br />`{"hash": "data", "height": n}`|
[Return to Overview](#ExtMethodOverview)<br />

***

<a name="getcurrentnet"/>

|   |   |
|---|---|
|Method|getcurrentnet|
|Parameters|None|
|Description|Get hc network hcd is running on.|
|Returns|numeric|
|Example Return|`3652501241` (mainnet)<br />`118034699` (testnet)|
[Return to Overview](#ExtMethodOverview)<br />

***

<a name="searchrawtransactions"/>

|   |   |
|---|---|
|Method|searchrawtransactions|
|Parameters|1. address (string, required) - hc address <br /> 2. verbose (int, optional, default=true) - specifies the transaction is returned as a JSON object instead of hex-encoded string <br />3. skip (int, optional, default=0) - the number of leading transactions to leave out of the final response <br /> 4. count (int, optional, default=100) - the maximum number of transactions to return <br /> 5. (vinextra int, optional, default=0) - Specify that extra data from previous output will be returned in vin|
|Description|Returns raw data for transactions involving the passed address. Returned transactions are pulled from both the database, and transactions currently in the mempool. Transactions pulled from the mempool will have the `"confirmations"` field set to 0. Usage of this RPC requires the optional `--addrindex` flag to be activated, otherwise all responses will simply return with an error stating the address index has not yet been built up. Similarly, until the address index has caught up with the current best height, all requests will return an error response in order to avoid serving stale data.|
|Returns (verbose=0)|`(json array of strings)`<br />`serializedtx`: hex-encoded bytes of the serialized transaction<br />`["serializedtx", ... ]` |
|Returns (verbose=1)|`(array of json objects)`<br/>`hex`: (string) hex-encoded transaction<br />`txid`: (string) the hash of the transaction<br />`version`: (numeric) the transaction version<br />`locktime`: (numeric) the transaction lock time<br />`vin`: the transaction inputs as json objects<br />`coinbase`: (string) the hex-encoded bytes of the signature script<br />`sequence`:  (numeric) the script sequence number<br />`txid`: (string) the hash of the origin transaction<br />`vout`: (numeric) the index of the output being redeemed from the origin transaction<br />`scriptSig`: the signature script used to redeem the origin transaction<br />`asm`: (string) disassembly of the script<br />`hex`: (string) hex-encoded bytes of the script<br />`prevOut`: Data from the origin transaction output with index vout.<br />`addresses`:  (array of string) previous output addresses<br />`value`:            (numeric) previous output value<br />`sequence`: (numeric) the script sequence number<br />`vout`: (array of json objects) the transaction outputs as json objects<br />`value`: (numeric) the value in BTC<br />`n`: (numeric) the index of this transaction output<br />`scriptPubKey`: (json object) the public key script used to pay coins<br />`asm`: (string) disassembly of the script<br />`hex`: (string) hex-encoded bytes of the script<br />`reqSigs`:  (numeric) the number of required signatures<br />`type`: (string) the type of the script (e.g. 'pubkeyhash')<br />`addresses`: (json array of string) the hc addresses associated with this output <br />`address`:  (string) the hc address<br />`blockhash`: Hash of the block the transaction is part of.<br />`confirmations`: Number of numeric confirmations of block.<br /> `time`: Transaction time in seconds since the epoch.<br />`blocktime`: Block time in seconds since the epoch.<br/><br /><font color="orange">For coinbase transactions:</font><br /><br />`[{"hex": "data", "txid": "hash", "version": n, "locktime": n,"vin": [{"coinbase": "data",  "sequence": n},{"txid": "hash", "vout": n, "scriptSig": {"asm": "asm", "hex": "data"}, "prevOut": {"addresses": ["value", ...], "value": n.nnn}, "sequence": n}, ...],"vout": [{ "value": n,"n": n, "scriptPubKey": {"asm": "asm", "hex": "data", "reqSigs": n, "type": "scripttype", "addresses": ["address", ...]}}, ...], "blockhash":"hash", "confirmations":n, "time":t, "blocktime":t },...]`<br /><br /><font color="orange">For non-coinbase transactions:</font><br /><br />`[{"hex": "data", "txid": "hash", "version": n, "locktime": n,"vin": [{"txid": "hash", "vout": n, "scriptSig": {"asm": "asm", "hex": "data"}, "prevOut": {"addresses": ["value",...], "value": n.nnn}, "sequence": n}, ...],"vout": [{ "value": n,"n": n, "scriptPubKey": {"asm": "asm", "hex": "data", "reqSigs": n, "type": "scripttype", "addresses": ["address", ...]}}, ...], "blockhash":"hash", "confirmations":n, "time":t, "blocktime":t },...]`|
[Return to Overview](#ExtMethodOverview)<br />

***

<a name="node"/>

|   |   |
|---|---|
|Method|node|
|Parameters|1. `command`: `(string, required)`  `connect` to add a peer (defaults to temporary), `remove` to remove a persistent peer, or `disconnect` to remove all matching non-persistent peers.<br /> 2. `peer`: `(string, required)` ip address and port, or ID of the peer to operate on.<br /> 3. `connection type`: `(string, optional)` `perm` indicates the peer should be added as a permanent peer, `temp` indicates a connection should only be attempted once. |
|Description|Attempts to add or remove a peer.|
|Returns|Nothing|
[Return to Overview](#MethodOverview)<br />

***

<a name="generate"/>

|   |   |
|---|---|
|Method|generate|
|Parameters|1. `numblocks`: `(int, required)` The number of blocks to generate. |
|Description|When in simnet or regtest mode, generates `numblocks` blocks. If blocks arrive from elsewhere, they are built upon but don't count toward the number of blocks to generate. Only generated blocks are returned. This RPC call will exit with an error if the server is already CPU mining, and will prevent the server from CPU mining for another command while it runs. |
|Returns|`(json array of strings)`<br/> `blockhash`: hash of the generated block.<br/>`["blockhash", ...]` |
[Return to Overview](#MethodOverview)<br />

<a name="getstakeversions"/>

|   |   |
|---|---|
|Method|getstakeversions|
|Parameters|1. `hash`: `(string, required)` The start block hash. <br /> 2. `count`: `(numeric, required)` The number of blocks that will be returned. |
|Description| Returns the stake versions statistics. |
|Returns|`stakeversions`: `(array of object)` Array of stake versions per block. <br /> `hash`: `(string)` hash of the block. <br /> `height`: `(numeric)` Height of the block. <br /> `blockversion`: `(numeric)` the block version. <br /> `stakeversion`: `(numeric)` the stake version of the block. <br /> `votes`: `(array of object)` the version and bits of each vote in the block. <br /> `version`: `(numeric)` the version of the vote. <br /> `bits`: `(numeric)` the bits assigned by the vote. <br /><br /> `{"stakeversions": [{ "hash": "value", "height": n, "blockversion": n, "stakeversion": n,"votes": [{ "version": n, "bits": n },...]},...]}` |
[Return to Overview](#MethodOverview)<br />

***

<a name="WSMethods" />

### 6. Websocket Methods (Websocket-specific)

<a name="WSMethodOverview" />

**6.1 Method Overview**<br />

The following is an overview of the RPC method requests available exclusively to Websocket clients.  All of these RPC methods are available to the limited
user.  Click the method name for further details such as parameter and return information.

|#|Method|Description|Notifications|
|---|------|-----------|-------------|
|1|[authenticate](#authenticate)|Authenticate the connection against the username and passphrase configured for the RPC server.<br /><br />NOTE: This is only required if an HTTP Authorization header is not being used.|None|
|2|[notifyblocks](#notifyblocks)|Send notifications when a block is connected or disconnected from the best chain.|[blockconnected](#blockconnected) and [blockdisconnected](#blockdisconnected)|
|3|[stopnotifyblocks](#stopnotifyblocks)|Cancel registered notifications for whenever a block is connected or disconnected from the main (best) chain. |None|
|4|[notifyreceived](#notifyreceived)|Send notifications when a txout spends to an address.|[recvtx](#recvtx) and [redeemingtx](#redeemingtx)|
|5|[stopnotifyreceived](#stopnotifyreceived)|Cancel registered notifications for when a txout spends to any of the passed addresses.|None|
|6|[notifyspent](#notifyspent)|Send notification when a txout is spent.|[redeemingtx](#redeemingtx)|
|7|[stopnotifyspent](#stopnotifyspent)|Cancel registered spending notifications for each passed outpoint.|None|
|8|[loadtxfilter](#loadtxfilter)|Load, add to, or reload a websocket client's transaction filter for mempool transactions, new blocks and rescanblocks.|[relevanttxaccepted](#relevanttxaccepted)|
|9|[rescan](#rescan)|Rescan block chain for transactions to addresses and spent transaction outpoints.|[recvtx](#recvtx), [redeemingtx](#redeemingtx), [rescanprogress](#rescanprogress), and [rescanfinished](#rescanfinished) |
|10|[notifynewtransactions](#notifynewtransactions)|Send notifications for all new transactions as they are accepted into the mempool.|[txaccepted](#txaccepted) or [txacceptedverbose](#txacceptedverbose)|
|11|[stopnotifynewtransactions](#stopnotifynewtransactions)|Stop sending either a txaccepted or a txacceptedverbose notification when a new transaction is accepted into the mempool.|None|
|12|[session](#session)|Return details regarding a websocket client's current connection.|None|
<a name="WSExtMethodDetails" />

**6.2 Method Details**<br />

<a name="authenticate"/>

|   |   |
|---|---|
|Method|authenticate|
|Parameters|1. `username`: `(string, required)`<br />2. `passphrase`: `(string, required)`|
|Description|Authenticate the connection against the username and password configured for the RPC server. Invoking any other method before authenticating with this command will close the connection.<br /><br />NOTE: This is only required if an HTTP Authorization header is not being used.|
|Returns|`Success`: `Nothing`<br />`Failure`: `Nothing` `(websocket disconnected)`|
[Return to Overview](#WSMethodOverview)<br />

***

<a name="notifyblocks"/>

|   |   |
|---|---|
|Method|notifyblocks|
|Notifications|[blockconnected](#blockconnected) and [blockdisconnected](#blockdisconnected)|
|Parameters|None|
|Description|Request notifications for whenever a block is connected or disconnected from the main (best) chain.<br />NOTE: If a client subscribes to both block and transaction (recvtx and redeemingtx) notifications, the blockconnected notification will be sent after all transaction notifications have been sent.  This allows clients to know when all relevant transactions for a block have been received.|
|Returns|Nothing|
[Return to Overview](#WSMethodOverview)<br />

***
<a name="stopnotifyblocks"/>

|   |   |
|---|---|
|Method|stopnotifyblocks|
|Notifications|None|
|Parameters|None|
|Description|Cancel sending notifications for whenever a block is connected or disconnected from the main (best) chain.|
|Returns|Nothing|
[Return to Overview](#WSMethodOverview)<br />

***

<a name="notifyreceived"/>

|   |   |
|---|---|
|Method|notifyreceived|
|Notifications|[recvtx](#recvtx) and [redeemingtx](#redeemingtx)|
|Parameters|1. Addresses (JSON array, required)<br />`(json array of strings)`<br />`hcaddress`: (string) the hc address<br />`["hcaddress", ...]`|
|Description|Send a recvtx notification when a transaction added to mempool or appears in a newly-attached block contains a txout pkScript sending to any of the passed addresses.  Matching outpoints are automatically registered for redeemingtx notifications.|
|Returns|Nothing|
[Return to Overview](#WSMethodOverview)<br />

***

<a name="stopnotifyreceived"/>

|   |   |
|---|---|
|Method|stopnotifyreceived|
|Notifications|None|
|Parameters|1. Addresses (JSON array, required)<br />`(json array of strings)`<br />`hcaddress`: (string) the hc address<br />`["hcaddress", ...]`|
|Description|Cancel registered receive notifications for each passed address.|
|Returns|Nothing|
[Return to Overview](#WSMethodOverview)<br />

***

<a name="notifyspent"/>

|   |   |
|---|---|
|Method|notifyspent|
|Notifications|[redeemingtx](#redeemingtx)|
|Parameters|1. Outpoints (JSON array, required)<br />`(JSON array)`<br /> `hash`: (string) the hex-encoded bytes of the outpoint hash<br />`index`: (numeric) the txout index of the outpoint<br />`[{"hash":"data", "index":n }, ...]`|
|Description|Send a redeemingtx notification when a transaction spending an outpoint appears in mempool (if relayed to this hcd instance) and when such a transaction first appears in a newly-attached block.|
|Returns|Nothing|
[Return to Overview](#WSMethodOverview)<br />

***

<a name="stopnotifyspent"/>

|   |   |
|---|---|
|Method|stopnotifyspent|
|Notifications|None|
|Parameters|1. `Outpoints`: `(json array, required)`<br />`hash`: `(string)` the hex-encoded bytes of the outpoint hash.<br />`index`: `(numeric)` the txout index of the outpoint.<br /><br />`[{"hash":"data", "index":n }, ...]`|
|Description|Cancel registered spending notifications for each passed outpoint.|
|Returns|Nothing|
[Return to Overview](#WSMethodOverview)<br />

***

<a name="loadtxfilter"/>

 |   |   |
 |---|---|
 |Method|loadtxfilter|
 |Notifications|[relevanttxaccepted](#relevanttxaccepted)|
 |Parameters|1. `Reload`: `(boolean, required)` load a new filter instead of adding data to an existing one.<br />2. `Addresses`: `(json array, required)` array of addresses to add to the transaction filter<br />3. `Outpoints`: `(JSON array, required)` array of outpoints to add to the transaction filter.|
 |Description|Load, add to, or reload a websocket client's transaction filter for mempool transactions, new blocks and [rescanblocks](#rescanblocks).|
 |Returns|Nothing|
 [Return to Overview](#WSMethodOverview)<br />

 ***

<a name="rescan"/>

|   |   |
|---|---|
|Method|rescan|
|Notifications|[recvtx](#recvtx), [redeemingtx](#redeemingtx), [rescanprogress](#rescanprogress), and [rescanfinished](#rescanfinished)|
|Parameters|1. BeginBlock (string, required) block hash to begin rescanning from<br /><br />2. Addresses (JSON array, required)<br />`(json array of strings)`<br />`hcaddress`: (string) the hc address<br />`[ "hcaddress", ...]`<br /><br />3. Outpoints (JSON array, required)<br />`(JSON array)`<br />`hash`: (string) the hex-encoded bytes of the outpoint hash<br /> `index`: (numeric) the txout index of the outpoint<br />`[{"hash":"data", "index":n }, ...]`<br /><br /> 4. EndBlock (string, optional) hash of final block to rescan|
|Description|Rescan block chain for transactions to addresses, starting at block BeginBlock and ending at EndBlock.  The current known UTXO set for all passed addresses at height BeginBlock should included in the Outpoints argument.  If EndBlock is omitted, the rescan continues through the best block in the main chain.  Additionally, if no EndBlock is provided, the client is automatically registered for transaction notifications for all rescanned addresses and the final UTXO set.  Rescan results are sent as recvtx and redeemingtx notifications.  This call returns once the rescan completes.|
|Returns|Nothing|
[Return to Overview](#WSExtMethodOverview)<br />


<a name="notifynewtransactions"/>

|   |   |
|---|---|
|Method|notifynewtransactions|
|Notifications|[txaccepted](#txaccepted) or [txacceptedverbose](#txacceptedverbose)|
|Parameters|1. `verbose`: `(boolean, optional, default=false)` specifies which type of notification to receive.  If verbose is true, then the caller receives [txacceptedverbose](#txacceptedverbose), otherwise the caller receives [txaccepted](#txaccepted)|
|Description|Send either a [txaccepted](#txaccepted) or a [txacceptedverbose](#txacceptedverbose) notification when a new transaction is accepted into the mempool.|
|Returns|Nothing|
[Return to Overview](#WSMethodOverview)<br />

***

<a name="stopnotifynewtransactions"/>

|   |   |
|---|---|
|Method|stopnotifynewtransactions|
|Notifications|None|
|Parameters|None|
|Description|Stop sending either a [txaccepted](#txaccepted) or a [txacceptedverbose](#txacceptedverbose) notification when a new transaction is accepted into the mempool.|
|Returns|Nothing|
[Return to Overview](#WSMethodOverview)<br />

***

<a name="session"/>

|   |   |
|---|---|
|Method|session|
|Notifications|None|
|Parameters|None|
|Description|Return a JSON object with details regarding a websocket client's current connection to the RPC server.  This currently only includes the session ID, a random unsigned 64-bit integer that is created for each newly connected client.  Session IDs may be used to verify that the current connection was not lost and subsequently reestablished.|
|Returns|`(json object)`<br />`sessionid`: `(numeric)` the session ID.<br /><br />`{"sessionid": n}`|
|Example Return|`{"sessionid": 67089679842}`|
[Return to Overview](#WSMethodOverview)<br />


<a name="Notifications" />

### 7. Notifications (Websocket-specific)

hcd uses standard JSON-RPC notifications to notify clients of changes, rather than requiring clients to poll hcd for updates.  JSON-RPC notifications are a subset of requests, but do not contain an ID.  The notification type is categorized by the `method` field and additional details are sent as a JSON array in the `params` field.

<a name="NotificationOverview" />

**7.1 Notification Overview**<br />

The following is an overview of the JSON-RPC notifications used for Websocket connections.  Click the method name for further details of the context(s) in which they are sent and their parameters.

|#|Method|Description|Request|
|---|------|-----------|-------|
|1|[blockconnected](#blockconnected)|Block connected to the main chain.|[notifyblocks](#notifyblocks)|
|2|[blockdisconnected](#blockdisconnected)|Block disconnected from the main chain.|[notifyblocks](#notifyblocks)|
|3|[recvtx](#recvtx)|Processed a transaction output spending to a wallet address.|[notifyreceived](#notifyreceived) and [rescan](#rescan)|
|4|[redeemingtx](#redeemingtx)|Processed a transaction that spends a registered outpoint.|[notifyspent](#notifyspent) and [rescan](#rescan)|
|5|[txaccepted](#txaccepted)|Received a new transaction after requesting simple notifications of all new transactions accepted into the mempool.|[notifynewtransactions](#notifynewtransactions)|
|6|[txacceptedverbose](#txacceptedverbose)|Received a new transaction after requesting verbose notifications of all new transactions accepted into the mempool.|[notifynewtransactions](#notifynewtransactions)|
|7|[rescanprogress](#rescanprogress)|A rescan operation that is underway has made progress.|[rescan](#rescan)|
|8|[rescanfinished](#rescanfinished)|A rescan operation has completed.|[rescan](#rescan)|

<a name="NotificationDetails" />

**7.2 Notification Details**<br />

<a name="blockconnected"/>

|   |   |
|---|---|
|Method|blockconnected|
|Request|[notifyblocks](#notifyblocks)|
|Parameters|1. `BlockHash`: `(string)` hex-encoded bytes of the attached block hash.<br />2. `BlockHeight`: `(numeric)` height of the attached block.<br />3. `BlockTime`: `(numeric)` unix time of the attached block.|
|Description|Notifies when a block has been added to the main chain.  Notification is sent to all connected clients.|
|Example|Example blockconnected notification for mainnet block 280330 (newlines added for readability):<br /><br />`{"jsonrpc": "1.0", "method": "blockconnected", "params": ["000000000000000004cbdfe387f4df44b914e464ca79838a8ab777b3214dbffd", 280330, 1389636265],"id": null}`|
[Return to Overview](#NotificationOverview)<br />

***

<a name="blockdisconnected"/>

|   |   |
|---|---|
|Method|blockdisconnected|
|Request|[notifyblocks](#notifyblocks)|
|Parameters|1. `BlockHash`: `(string)` hex-encoded bytes of the disconnected block hash.<br />2. `BlockHeight`: `(numeric)` height of the disconnected block.<br />3. `BlockTime`: `(numeric)` unix time of the disconnected block.|
|Description|Notifies when a block has been removed from the main chain.  Notification is sent to all connected clients.|
|Example|Example blockdisconnected notification for mainnet block 280330 (newlines added for readability):<br /><br />`{"jsonrpc": "1.0","method": "blockdisconnected", "params":["000000000000000004cbdfe387f4df44b914e464ca79838a8ab777b3214dbffd", 280330,1389636265],"id": null}`|
[Return to Overview](#NotificationOverview)<br />

***

<a name="recvtx"/>

|   |   |
|---|---|
|Method|recvtx|
|Request|[rescan](#rescan) or [notifyreceived](#notifyreceived)|
|Parameters|1. `Transaction`: `(string)` full transaction encoded as a hex string.<br />2. `Block details`: `(object, optional)` details about a block and the index of the transaction within a block, if the transaction is mined.|
|Description|Notifies a client when a transaction is processed that contains at least a single output with a pkScript sending to a requested address.  If multiple outputs send to requested addresses, a single notification is sent.  If a mempool (unmined) transaction is processed, the block details object (second parameter) is excluded.|
|Example|Example recvtx notification for mainnet transaction `61d3696de4c888730cbe06b0ad8ecb6d72d6108e893895aa9bc067bd7eba3fad` when processed by mempool (newlines added for readability):<br /><br />`{"jsonrpc": "1.0", "method": "recvtx", "params": ["010000000114d9ff358894c486b4ae11c2a8cf7851b1df64c53d2e511278eff17c22fb737300000000...], "id": null }`<br /><br />The recvtx notification for the same txout, after the transaction was mined into block `276425`:<br /><br />`{"jsonrpc": "1.0","method": "recvtx", "params": ["010000000114d9ff358894c486b4ae11c2a8cf7851b1df64c53d2e511278eff17c22fb737300000000...", {"height": 276425, "hash": "000000000000000325474bb799b9e591f965ca4461b72cb7012b808db92bb2fc", "index": 684, "time": 1387737310 }], "id": null }`|
[Return to Overview](#NotificationOverview)<br />

***
<a name="redeemingtx"/>

|   |   |
|---|---|
|Method|redeemingtx|
|Requests|[notifyspent](#notifyspent) and [rescan](#rescan)|
|Parameters|1. `Transaction`: `(string)` full transaction encoded as a hex string.<br />2. `Block details`: `(object, optional)` details about a block and the index of the transaction within a block, if the transaction is mined.|
|Description|Notifies a client when an registered outpoint is spent by a transaction accepted to mempool and/or mined into a block.|
|Example|Example redeemingtx notification for mainnet outpoint `61d3696de4c888730cbe06b0ad8ecb6d72d6108e893895aa9bc067bd7eba3fad:0` after being spent by transaction `4ad0c16ac973ff675dec1f3e5f1273f1c45be2a63554343f21b70240a1e43ece` (newlines added for readability):<br /><br />`{"jsonrpc": "1.0", "method": "redeemingtx", "params": ["0100000003ad3fba7ebd67c09baa9538898e10d6726dcb8eadb006be0c7388c8e46d69d3610000000..."],"id": null}`<br /><br />The redeemingtx notification for the same txout, after the spending transaction was mined into block `279143`:<br /><br />`{"jsonrpc": "1.0", "method": "recvtx", "params": ["0100000003ad3fba7ebd67c09baa9538898e10d6726dcb8eadb006be0c7388c8e46d69d3610000000...", {"height": 279143, "hash": "00000000000000017188b968a371bab95aa43522665353b646e41865abae02a4", "index": 6, "time": 1389115004 }], "id": null }`|
[Return to Overview](#NotificationOverview)<br />

***

<a name="txaccepted"/>

|   |   |
|---|---|
|Method|txaccepted|
|Request|[notifynewtransactions](#notifynewtransactions)|
|Parameters|1. `TxSha`: `(string)` hex-encoded bytes of the transaction hash.<br />2. `Amount`: `(numeric)` sum of the value of all the transaction outpoints.|
|Description|Notifies when a new transaction has been accepted and the client has requested standard transaction details.|
|Example|Example txaccepted notification for mainnet transaction id `16c54c9d02fe570b9d41b518c0daefae81cc05c69bbe842058e84c6ed5826261` (newlines added for readability):<br /><br />`{"jsonrpc": "1.0", "method": "txaccepted", "params": ["16c54c9d02fe570b9d41b518c0daefae81cc05c69bbe842058e84c6ed5826261", 55838384], "id": null}`|
[Return to Overview](#NotificationOverview)<br />

***

<a name="txacceptedverbose"/>

|   |   |
|---|---|
|Method|txacceptedverbose|
|Request|[notifynewtransactions](#notifynewtransactions)|
|Parameters|1. `RawTx`: `(json object)` the transaction as a json object (see getrawtransaction json object details).|
|Description|Notifies when a new transaction has been accepted and the client has requested verbose transaction details.|
|Example|Example txacceptedverbose notification (newlines added for readability):<br /><br />**For coinbase transactions**<br />`{"jsonrpc": "1.0", "method": "txacceptedverbose", "params": [{"hex": "01000000010000000000000000000000000000000000000000000000000000000000000000f...", "txid": "90743aad855880e517270550d2a881627d84db5265142fd1e7fb7add38b08be9", "version": 1, "locktime": 0, "vin": [{"coinbase": "03708203062f503253482f04066d605108f800080100000ea2122f6f7a636f696e4065757374726174756d2f", "sequence": 0}, ...], "vout": [{"value": 25.1394, "n": 0,"scriptPubKey": {"asm": "OP_DUP OP_HASH160 ea132286328cfc819457b9dec386c4b5c84faa5c OP_EQUALVERIFY OP_CHECKSIG", "hex": "76a914ea132286328cfc819457b9dec386c4b5c84faa5c88ac", "reqSigs": 1,"type": "pubkeyhash", "addresses": ["1NLg3QJMsMQGM5KEUaEu5ADDmKQSLHwmyh", ...]}]}], "id": null}`<br /><br />**For non-coinbase transactions**<br />`{"jsonrpc": "1.0", "method": "txacceptedverbose", "params": [{"hex": "01000000010000000000000000000000000000000000000000000000000000000000000000f...", "txid": "90743aad855880e517270550d2a881627d84db5265142fd1e7fb7add38b08be9", "version": 1, "locktime": 0, "vin": [{"txid": "60ac4b057247b3d0b9a8173de56b5e1be8c1d1da970511c626ef53706c66be04","vout": 0, "scriptSig": {"asm": "3046022100cb42f8df44eca83dd0a727988dcde9384953e830b1f8004d57485e2ede1b9c8f0...", "hex": "493046022100cb42f8df44eca83dd0a727988dcde9384953e830b1f8004d57485e2ede1b9c8..."}, "sequence": 4294967295}, ...], "vout": [{"value": 25.1394, "n": 0,"scriptPubKey": {"asm": "OP_DUP OP_HASH160 ea132286328cfc819457b9dec386c4b5c84faa5c OP_EQUALVERIFY OP_CHECKSIG", "hex": "76a914ea132286328cfc819457b9dec386c4b5c84faa5c88ac", "reqSigs": 1,"type": "pubkeyhash", "addresses": ["1NLg3QJMsMQGM5KEUaEu5ADDmKQSLHwmyh", ...]}]}], "id": null}`|
[Return to Overview](#NotificationOverview)<br />

***

<a name="rescanprogress"/>

|   |   |
|---|---|
|Method|rescanprogress|
|Request|[rescan](#rescan)|
|Parameters|1. `Hash`: `(string)` hash of the last processed block.<br />2. `Height`: `(numeric)` height of the last processed block.<br />3. `Time`: `(numeric)` UNIX time of the last processed block.|
|Description|Notifies a client with the current progress at periodic intervals when a long-running [rescan](#rescan) is underway.|
|Example|`{"jsonrpc": "1.0", "method": "rescanprogress", "params": ["0000000000000ea86b49e11843b2ad937ac89ae74a963c7edd36e0147079b89d", 127213, 1306533807], "id": null }`|
[Return to Overview](#NotificationOverview)<br />

***

<a name="rescanfinished"/>

|   |   |
|---|---|
|Method|rescanfinished|
|Request|[rescan](#rescan)|
|Parameters|1. `Hash`: `(string)` hash of the last rescanned block.<br />2. `Height`: `(numeric)` height of the last rescanned block.<br />3. `Time`: `(numeric)` UNIX time of the last rescanned block.|
|Description|Notifies a client that the [rescan](#rescan) has completed and no further notifications will be sent.|
|Example|`{"jsonrpc": "1.0", "method": "rescanfinished", "params": ["0000000000000ea86b49e11843b2ad937ac89ae74a963c7edd36e0147079b89d", 127213, 1306533807], "id": null }`|
[Return to Overview](#NotificationOverview)<br />


<a name="ExampleCode" />

### 8. Example Code

This section provides example code for interacting with the JSON-RPC API in
various languages.

* [Go](#ExampleGoApp)
* [node.js](#ExampleNodeJsCode)

<a name="ExampleGoApp" />

**8.1 Go**

This section provides examples of using the RPC interface using Go and the
[hcrpcclient](https://github.com/james-ray/hcrpcclient) package.

* [Using getblockcount to Retrieve the Current Block Height](#ExampleGetBlockCount)
* [Using getblock to Retrieve the Genesis Block](#ExampleGetBlock)
* [Using notifyblocks to Receive blockconnected and blockdisconnected Notifications (Websocket-specific)](#ExampleNotifyBlocks)


<a name="ExampleGetBlockCount" />

**8.1.1 Using getblockcount to Retrieve the Current Block Height**<br />

The following is an example Go application which uses the
[hcrpcclient](https://github.com/james-ray/hcrpcclient) package to connect with
a hcd instance via Websockets, issues [getblockcount](#getblockcount) to
retrieve the current block height, and displays it.

```Go
package main

import (
	"github.com/james-ray/hcrpcclient"
	"github.com/james-ray/hcd/hcutil"
	"io/ioutil"
	"log"
	"path/filepath"
)

func main() {
	// Load the certificate for the TLS connection which is automatically
	// generated by hcd when it starts the RPC server and doesn't already
	// have one.
	hcdHomeDir := hcutil.AppDataDir("hcd", false)
	certs, err := ioutil.ReadFile(filepath.Join(hcdHomeDir, "rpc.cert"))
	if err != nil {
		log.Fatal(err)
	}

	// Create a new RPC client using websockets.  Since this example is
	// not long-lived, the connection will be closed as soon as the program
	// exits.
	connCfg := &hcrpcclient.ConnConfig{
		Host:         "localhost:14009",
		Endpoint:     "ws",
		User:         "yourrpcuser",
		Pass:         "yourrpcpass",
		Certificates: certs,
	}
	client, err := hcrpcclient.New(connCfg, nil)
	if err != nil {
		log.Fatal(err)
	}
	defer client.Shutdown()

	// Query the RPC server for the current block count and display it.
	blockCount, err := client.GetBlockCount()
	if err != nil {
		log.Fatal(err)
	}
	log.Printf("Block count: %d", blockCount)
}
```

Which results in:

```bash
Block count: 276978
```

<a name="ExampleGetBlock" />

**8.1.2 Using getblock to Retrieve the Genesis Block**<br />

The following is an example Go application which uses the
[hcrpcclient](https://github.com/james-ray/hcrpcclient) package to connect with
a hcd instance via Websockets, issues [getblock](#getblock) to retrieve
information about the Genesis block, and display a few details about it.

```Go
package main

import (
	"github.com/james-ray/hcrpcclient"
	"github.com/james-ray/hcd/hcutil"
	"github.com/james-ray/hcd/wire"
	"io/ioutil"
	"log"
	"path/filepath"
	"time"
)

func main() {
	// Load the certificate for the TLS connection which is automatically
	// generated by hcd when it starts the RPC server and doesn't already
	// have one.
	hcdHomeDir := hcutil.AppDataDir("hcd", false)
	certs, err := ioutil.ReadFile(filepath.Join(hcdHomeDir, "rpc.cert"))
	if err != nil {
		log.Fatal(err)
	}

	// Create a new RPC client using websockets.  Since this example is
	// not long-lived, the connection will be closed as soon as the program
	// exits.
	connCfg := &hcrpcclient.ConnConfig{
		Host:         "localhost:14009",
		Endpoint:     "ws",
		User:         "yourrpcuser",
		Pass:         "yourrpcpass",
		Certificates: certs,
	}
	client, err := hcrpcclient.New(connCfg, nil)
	if err != nil {
		log.Fatal(err)
	}
	defer client.Shutdown()

	// Query the RPC server for the genesis block using the "getblock"
	// command with the verbose flag set to true and the verboseTx flag
	// set to false.
	genesisHashStr := "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f"
	blockHash, err := wire.NewShaHashFromStr(genesisHashStr)
	if err != nil {
		log.Fatal(err)
	}
	block, err := client.GetBlockVerbose(blockHash, false)
	if err != nil {
		log.Fatal(err)
	}

	// Display some details about the returned block.
	log.Printf("Hash: %v\n", block.Hash)
	log.Printf("Previous Block: %v\n", block.PreviousHash)
	log.Printf("Next Block: %v\n", block.NextHash)
	log.Printf("Merkle root: %v\n", block.MerkleRoot)
	log.Printf("Timestamp: %v\n", time.Unix(block.Time, 0).UTC())
	log.Printf("Confirmations: %v\n", block.Confirmations)
	log.Printf("Difficulty: %f\n", block.Difficulty)
	log.Printf("Size (in bytes): %v\n", block.Size)
	log.Printf("Num transactions: %v\n", len(block.Tx))
}
```

Which results in:

```bash
Hash: 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
Previous Block: 0000000000000000000000000000000000000000000000000000000000000000
Next Block: 00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048
Merkle root: 4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b
Timestamp: 2009-01-03 18:15:05 +0000 UTC
Confirmations: 277290
Difficulty: 1.000000
Size (in bytes): 285
Num transactions: 1
```

<a name="ExampleNotifyBlocks" />

**8.1.3 Using notifyblocks to Receive blockconnected and blockdisconnected
Notifications (Websocket-specific)**<br />

The following is an example Go application which uses the
[hcrpcclient](https://github.com/james-ray/hcrpcclient) package to connect with
a hcd instance via Websockets and registers for
[blockconnected](#blockconnected) and [blockdisconnected](#blockdisconnected)
notifications with [notifyblocks](#notifyblocks).  It also sets up handlers for
the notifications.

```Go
package main

import (
	"github.com/james-ray/hcrpcclient"
	"github.com/james-ray/hcd/hcutil"
	"github.com/james-ray/hcd/wire"
	"io/ioutil"
	"log"
	"path/filepath"
	"time"
)

func main() {
	// Setup handlers for blockconnected and blockdisconnected
	// notifications.
	ntfnHandlers := hcrpcclient.NotificationHandlers{
		OnBlockConnected: func(hash *wire.ShaHash, height int32) {
			log.Printf("Block connected: %v (%d)", hash, height)
		},
		OnBlockDisconnected: func(hash *wire.ShaHash, height int32) {
			log.Printf("Block disconnected: %v", hash, height)
		},
	}

	// Load the certificate for the TLS connection which is automatically
	// generated by hcd when it starts the RPC server and doesn't already
	// have one.
	hcdHomeDir := hcutil.AppDataDir("hcd", false)
	certs, err := ioutil.ReadFile(filepath.Join(hcdHomeDir, "rpc.cert"))
	if err != nil {
		log.Fatal(err)
	}

	// Create a new RPC client using websockets.
	connCfg := &hcrpcclient.ConnConfig{
		Host:         "localhost:14009",
		Endpoint:     "ws",
		User:         "yourrpcuser",
		Pass:         "yourrpcpass",
		Certificates: certs,
	}
	client, err := hcrpcclient.New(connCfg, &ntfnHandlers)
	if err != nil {
		log.Fatal(err)
	}

	// Register for blockconnected and blockdisconneted notifications.
	if err := client.NotifyBlocks(); err != nil {
		client.Shutdown()
		log.Fatal(err)
	}

	// For this example, gracefully shutdown the client after 10 seconds.
	// Ordinarily when to shutdown the client is highly application
	// specific.
	log.Println("Client shutdown in 10 seconds...")
	time.AfterFunc(time.Second*10, func() {
		log.Println("Client shutting down...")
		client.Shutdown()
		log.Println("Client shutdown complete.")
	})

	// Wait until the client either shuts down gracefully (or the user
	// terminates the process with Ctrl+C).
	client.WaitForShutdown()
}
```

Example output:

```
2014/05/12 20:33:17 Client shutdown in 10 seconds...
2014/05/12 20:33:19 Block connected: 000000000000000007dff1f95f7b3f5eac2892a4123069517caf34e2c417650d (300461)
2014/05/12 20:33:27 Client shutting down...
2014/05/12 20:31:27 Client shutdown complete.
```

<a name="ExampleNodeJsCode" />

### 8.2. Example node.js Code

<a name="ExampleNotifyBlocks" />

**8.2.1 Using notifyblocks to be Notified of Block Connects and Disconnects**<br />

The following is example node.js code which uses [ws](https://github.com/einaros/ws)
(can be installed with `npm install ws`) to connect with a hcd instance,
issues [notifyblocks](#notifyblocks) to register for
[blockconnected](#blockconnected) and [blockdisconnected](#blockdisconnected)
notifications, and displays all incoming messages.

```javascript
var fs = require('fs');
var WebSocket = require('ws');

// Load the certificate for the TLS connection which is automatically
// generated by hcd when it starts the RPC server and doesn't already
// have one.
var cert = fs.readFileSync('/path/to/hcd/appdata/rpc.cert');
var user = "yourusername";
var password = "yourpassword";


// Initiate the websocket connection.  The hcd generated certificate acts as
// its own certificate authority, so it needs to be specified in the 'ca' array
// for the certificate to properly validate.
var ws = new WebSocket('wss://127.0.0.1:14009/ws', {
  headers: {
    'Authorization': 'Basic '+new Buffer(user+':'+password).toString('base64')
  },
  cert: cert,
  ca: [cert]
});
ws.on('open', function() {
    console.log('CONNECTED');
    // Send a JSON-RPC command to be notified when blocks are connected and
    // disconnected from the chain.
    ws.send('{"jsonrpc":"1.0","id":"0","method":"notifyblocks","params":[]}');
});
ws.on('message', function(data, flags) {
    console.log(data);
});
ws.on('error', function(derp) {
  console.log('ERROR:' + derp);
})
ws.on('close', function(data) {
  console.log('DISCONNECTED');
})
```
